<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-01-25T12:28:43+08:00</updated><id>/feed.xml</id><title type="html">Bingwhispers</title><subtitle>Hi there!</subtitle><entry><title type="html">今非昔比的书店</title><link href="/2020/05/20/bookshop-changed" rel="alternate" type="text/html" title="今非昔比的书店" /><published>2020-05-20T22:45:00+08:00</published><updated>2020-05-20T22:45:00+08:00</updated><id>/2020/05/20/bookshop-changed</id><content type="html" xml:base="/2020/05/20/bookshop-changed"><![CDATA[<p>  今天吃完午饭，我和子晨去了附近的一家书店。这家书店有一个奇怪的名字——言几又。</p>

<p>  我很少去书店，几乎所有的书都是从网上买。之所以会去言几又，是因为小珂单位发了一张预付卡。而书店又恰好离公司非常近，我就期望着多少能买几本书。</p>

<p>  刚迈进书店大门，一股书店特有的书香扑鼻而来。环顾四周，整个书店宽敞明亮，富丽堂皇。天花板上悬吊着形态各异的灯具。众多明亮的日光灯中，间或参杂着几盏外型极具特色但亮度稍弱的装饰灯。这种微弱的黄晕散发自书店的各个角落，给人以温馨舒适的感觉。高大宽阔的书架在灯光的照耀下，反射出雍容华贵的实木光泽。走廊尽头，一面大镜子完全覆盖了整个墙壁。走过去，不仔细看都不容易发现镜子的存在，只感觉置身于无尽的书海中。大厅正中间有一个巨大的旋转楼梯，通向二楼。人们沿着楼梯上上下下，又为书店增添了一些市井的热闹气息。</p>

<p>  在书店的两个角落，各有一个咖啡厅和理发厅。咖啡厅里坐了不少人，有的捧着咖啡和好友低声细语，有的靠在沙发上看书。</p>

<p>  相比起来，理发厅就冷清多了。大概是来书店逛的人们大多都还没做好理发的准备吧。</p>

<p>  “这不知道比其他的书店高到哪里去了！”我这样想。</p>

<p>  逛了一小会，我就发现了一个大问题：整个书店没有明显的导览设施。各类书籍都杂乱地混合摆放在一起。我想买些计算机专业类的书籍，结果绕了一圈，连一本都没找到。问过店员才知道，书店里根本没有专业书籍。</p>

<p>  我这才审视起这家书店的藏书。</p>

<p>  书架都很高，直顶天花板。书架低处摆着新面世的书。这些书并非像图书馆中书脊靠书脊地摆着，而是直接立起来，封面对着读者。这样看起来视觉效果确实很棒，但仔细想想，这种方法的空间里用率非常低，一层并不能摆多少本书。而且，还有不少书架上摆着一些古玩字画等文创产品。很多书架的最上面几层，干脆就摆着一些假书，以充场面，就像很多健身房里的书架一样。</p>

<p>  整个书店的藏书以“励志鸡汤”、经济生活和历史文化等畅销书为主。很难找到名家经典书籍，甚至是四大名著和国外名著小说都没有。在普通书店这些书，往往都占据了相当多的书架空间。</p>

<p>  最后，我和子晨发现喝咖啡才是消费这张预付卡最合算的方法。坐在角落的卡座里，我俩一人点了一杯冰拿铁，吹着空调，悠然地享受起这优美的环境。环顾四周，我想起上次去小寨的汉唐书城。汉唐书城这两年也有了大变样，和言几又很像，都加入了更多休闲和流行元素。在电商和电子书迅猛发展的冲击下，传统图书零售业日渐萧条。为了生存，很多书店不断探索和转型。书店老板也要赚钱养家，这本无可厚非。但是书店曾是文化和知识的代表，如今却将要慢慢褪去她的深韵，加入消费领域的滚滚大军中，不禁令人唏嘘。</p>

<p>  小时候跟着爸爸去图书批发市场进货。大人们谈生意，我就在旁边找喜欢的书翻阅。最后谈妥了生意，临走时老板大多会让我挑几本喜欢的书送给我。我还能记得从书店里走出来，手里捧着书时，自己脸上洋溢的笑。然而这样的书店恐怕再也不会有了。</p>

<p align="right">——2020年05月20日</p>

<p>  周末，我和小珂再来的时候，书店以大扫除的名义暂停营业。两周后的今天，我和小珂第二次来，书店还是大门紧锁。门外有一位店员模样的人告诉我们，这家店已经半个月没有营业了，估计是要关门了。</p>

<p align="right">——2020年06月06日</p>]]></content><author><name></name></author><category term="书店" /><category term="消费" /><summary type="html"><![CDATA[  今天吃完午饭，我和子晨去了附近的一家书店。这家书店有一个奇怪的名字——言几又。]]></summary></entry><entry><title type="html">Put my cellphone away</title><link href="/2020/05/18/stay-away-from-cellphones" rel="alternate" type="text/html" title="Put my cellphone away" /><published>2020-05-18T11:31:00+08:00</published><updated>2020-05-18T11:31:00+08:00</updated><id>/2020/05/18/stay-away-from-cellphones</id><content type="html" xml:base="/2020/05/18/stay-away-from-cellphones"><![CDATA[<p>Recently I found myself very hard to fall asleep. Yesterday I happened to see <a href="https://medium.com/memos-of-the-future/using-iot-to-optimize-your-sleep-c9747bd8633e">this article</a>. The author explains why using cellphones before going to bed is harmful to sleep in this article. What he said seems to make sense. So I left my cellphone out of my bedroom before going to bed last night.</p>

<p>At first, I was not used to lying in bed without doing anything, and unconsciously tried to find something to focus on. It took me quite a long time to relax completely.</p>

<p>This morning, I awoke much earlier than usual. I tried to get my cellphone habitually before opening my eyes. However, of cause, I couldn’t. I forgot that I had left it in the living room. I would pick the cellphone up and play around with it if I had the cellphone near me at that time. The alarm had not gone off, which means I still had some time. I closed my eyes, tried to fall asleep again. However, I became wide awake soon.</p>

<p>I felt energetic more than ever. I quickly get washed and changed, made me breakfast of eggs and milk. When I finished all this, there was still plenty of time before going to work. I did some cleanning, read some pages of a book and listened to an English audio program.</p>

<p>I extended the time of the morning by putting my cellphone away. Spending too much time on cellphones isn’t only a waste of time, but also impact the sleep quality.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Recently I found myself very hard to fall asleep. Yesterday I happened to see this article. The author explains why using cellphones before going to bed is harmful to sleep in this article. What he said seems to make sense. So I left my cellphone out of my bedroom before going to bed last night. At first, I was not used to lying in bed without doing anything, and unconsciously tried to find something to focus on. It took me quite a long time to relax completely. This morning, I awoke much earlier than usual. I tried to get my cellphone habitually before opening my eyes. However, of cause, I couldn’t. I forgot that I had left it in the living room. I would pick the cellphone up and play around with it if I had the cellphone near me at that time. The alarm had not gone off, which means I still had some time. I closed my eyes, tried to fall asleep again. However, I became wide awake soon. I felt energetic more than ever. I quickly get washed and changed, made me breakfast of eggs and milk. When I finished all this, there was still plenty of time before going to work. I did some cleanning, read some pages of a book and listened to an English audio program. I extended the time of the morning by putting my cellphone away. Spending too much time on cellphones isn’t only a waste of time, but also impact the sleep quality.]]></summary></entry><entry><title type="html">修复 Linux 中的一个噪音问题</title><link href="/2020/05/17/fix-linux-popup-noise" rel="alternate" type="text/html" title="修复 Linux 中的一个噪音问题" /><published>2020-05-17T10:53:00+08:00</published><updated>2020-05-17T10:53:00+08:00</updated><id>/2020/05/17/fix-linux-popup-noise</id><content type="html" xml:base="/2020/05/17/fix-linux-popup-noise"><![CDATA[<p>  自从安装了 Kubuntu 20.04 后，我被一个噪音问题困扰了很久。系统在播放声音前，总会发出一两声短促的噪音。然后继续正常播放声音。后来经过一些研究，我在不久前解决了这个问题。</p>

<p>  刚安装完操作系统后，我安装了媒体播放器，体验音乐和电影的播放效果。在操作过程中，我注意到系统偶尔会发出的短促噪音。在网上搜索一阵，并且尝试了一些方法后，问题没有得到解决。我便放弃了，只当是驱动程序可能有缺陷。</p>

<p>  不过我渐渐地发现了一个规律：噪音只会在一段安静时间后，再次播放声音前产生。在持续播放声音过程中，从来没有噪音。这让我猜测到了一种可能的原因：系统在播放声音一段时间后可能会关闭音频设备，然后在下一次播放前再打开音频设备。打开音频设备的过程中有可能产生电信号的突变，继而产生短促的噪音。这种设计极有可能是基于省电的考虑。</p>

<p>  于是，我以“Linux save power audio noise”为关键词搜索了一番。在 Redhat 公开的 BUG 管理系统中，我找到了2017年报告的一个 BUG：<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1525104">《Bug 1525104 - Clicking noise when start or stop sound playing》</a>。</p>

<p>  这个 BUG 所描述的问题和我的相同，并且 Jeremy 似乎给出了解决问题的办法。</p>
<blockquote>
  <p>Jeremy Cline 2017-12-13 18:06:49 UTC</p>

  <p> Can you pass snd_hda_intel.power_save=0 on the kernel command line and see if that resolves your issue?</p>

  <p> Thanks</p>

  <p>Riku Seppala 2017-12-13 18:25:50 UTC</p>

  <p> Yes, that seems to resolve this for me.</p>
</blockquote>

<p>  这个方案虽然可行，但需要通过修改 grub 的配置来修改内核命令行参数。即有风险又麻烦，普通用户不好操作。我决定找一个更容易操作的方法。</p>

<p>  “snd_hda_intel.power_save=0”看起来是把“snd_hda_intel”内核模块的“power_save”参数设置为0。那么问题应该是出在这个内核模块上了。于是我下载了 ubuntu 的内核源码，找到了这个内核模块。经过一番搜索，找到了这部分代码(linux-source-5.4.0/sound/pci/hda/hda_intel.c)：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifdef CONFIG_PM
static int param_set_xint(const char *val, const struct kernel_param *kp);
static const struct kernel_param_ops param_ops_xint = {
	.set = param_set_xint,
	.get = param_get_int,
};
#define param_check_xint param_check_int

static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;
module_param(power_save, xint, 0644);
MODULE_PARM_DESC(power_save, "Automatic power-saving timeout "
		 "(in second, 0 = disable).");

static bool pm_blacklist = true;
module_param(pm_blacklist, bool, 0644);
MODULE_PARM_DESC(pm_blacklist, "Enable power-management blacklist");

/* reset the HD-audio controller in power save mode.
 * this may give more power-saving, but will take longer time to
 * wake up.
 */
static bool power_save_controller = 1;
module_param(power_save_controller, bool, 0644);
MODULE_PARM_DESC(power_save_controller, "Reset controller in power save mode.");
#else
#define power_save	0
#endif /* CONFIG_PM */
</code></pre></div></div>
<p>  阅读这段代码后，我发现 power_save 参数并非简单地开启或者关闭省电模式，而是一个超时时间。增大超时时间可以降低进入省电模式的频率，从而减少噪音产生的次数。设置0可以直接关闭省电模式。于是问题就变得简单了，我的台式电脑似乎并不那么在乎功耗，所以我决定关闭音频设备的省电模式。用这条命令可暂时关闭省电模式。系统重启后失效。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo echo 0 &gt; /sys/module/snd_hda_intel/parameters/power_save
</code></pre></div></div>
<p>  若要永久关闭设备的省电模式，在/etc/modprobe.d/中添加一个“disable_snd_hda_intel_power_save.conf”文件，在文件中添加这一行：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>options snd_hda_intel power_save=0
</code></pre></div></div>

<h3 id="一个更深入的问题">一个更深入的问题</h3>

<p>  为什么 Linux 中有这个问题，而 Windows 操作系统中没有？</p>

<p>  Linux 的文档中有一个章节：<a href="https://www.kernel.org/doc/html/v5.4/sound/hd-audio/notes.html">More Notes on HD-Audio Driver</a>。这一节中介绍了 HD-audio 设备的大致结构。这里引用其中一段：</p>
<blockquote>
  <p>The HD-audio component consists of two parts: the controller chip and the codec chips on the HD-audio bus. Linux provides a single driver for all controllers, snd-hda-intel. Although the driver name contains a word of a well-known hardware vendor, it’s not specific to it but for all controller chips by other companies. Since the HD-audio controllers are supposed to be compatible, the single snd-hda-driver should work in most cases. But, not surprisingly, there are known bugs and issues specific to each controller type. The snd-hda-intel driver has a bunch of workarounds for these as described below.</p>
</blockquote>

<p>  这里说：HD-audio 组件由控制器芯片和解码芯片组成。Linux 提供了控制器芯片的驱动程序。在 snd_hda_intel 模块中，我找到了解码芯片的省电模式的驱动代码(linux-source-5.4.0/sound/pci/hda/hda_codec.c)：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static void codec_set_power_save(struct hda_codec *codec, int delay)
{
	struct device *dev = hda_codec_dev(codec);

	if (delay == 0 &amp;&amp; codec-&gt;auto_runtime_pm)
		delay = 3000;

	if (delay &gt; 0) {
		pm_runtime_set_autosuspend_delay(dev, delay);
		pm_runtime_use_autosuspend(dev);
		pm_runtime_allow(dev);
		if (!pm_runtime_suspended(dev))
			pm_runtime_mark_last_busy(dev);
	} else {
		pm_runtime_dont_use_autosuspend(dev);
		pm_runtime_forbid(dev);
	}
}
</code></pre></div></div>
<p>  原来音频设备的低功耗是通过控制解码芯片来实现的。于是我猜测电脑主板上应该有这样一个解码芯片：在省电模式中断电，在工作模式中供电。</p>

<p>  我使用的是华硕 B85M-F 型号的主板，在华硕的官网中搜到了此主板的<a href="https://www.asus.com/au/Motherboards/B85MF/specifications/">规格说明</a>。此主板搭载了 Realtek® ALC887 8-Channel High Definition Audio CODEC 音频解码芯片。我又在网上找到了这个芯片的数据手册，里面有它的长相和引脚定义。它长这个样子：</p>

<p><img src="/assets/linux-popup-noise/ALC887.png" alt="debugger" /></p>

<p>  我在电脑主板上找到了这个芯片，然后把 snd_hda_intel 模块的省电模式打开，用万用表在它的供电引脚上量到了电平的变化。正如我之前猜测的一样：播放声音一段时间后，停止供电。播放声音前，恢复供电。</p>

<p>  最后，我抱着试试看的态度，换了一块硬盘，装上 Windows 10。经过半个多小时的测试，这个音频解码芯片的供电始终没有被切断。看来，Windows下的驱动并没有在低功耗方面理会此芯片。</p>

<p>  到此，这个问题不再扑朔迷离。然而这个问题引发了我更深地思考：当此问题初现的时候，我的第一印象是 Linux 在这些细节上处理的还不够成熟。然而经过以上研究过程，我认为是 Linux 的开发人员追求极致的风格导致了这些琐碎的问题。上文提及的2017年报告的 BUG，到现在依然被开发者们追踪并修改，我为这些开发者们的精神所折服。</p>
<p align="right">——2020年5月17日</p>]]></content><author><name></name></author><summary type="html"><![CDATA[  自从安装了 Kubuntu 20.04 后，我被一个噪音问题困扰了很久。系统在播放声音前，总会发出一两声短促的噪音。然后继续正常播放声音。后来经过一些研究，我在不久前解决了这个问题。]]></summary></entry><entry><title type="html">2020年的新年碎碎念</title><link href="/2020/01/02/30-years-old" rel="alternate" type="text/html" title="2020年的新年碎碎念" /><published>2020-01-02T19:50:00+08:00</published><updated>2020-01-02T19:50:00+08:00</updated><id>/2020/01/02/30-years-old</id><content type="html" xml:base="/2020/01/02/30-years-old"><![CDATA[<p>  昨天晚上，我和小珂出去吃饭。等餐的时候，和小珂闲在聊中谈到一年的变化。事后细想，感慨颇深。</p>

<p>  2019年对我来说很是丰富多彩。我做了很多有意义的事情，也有了很多真心想去做的事情。</p>

<p>  这一年夏天，我和小珂领了结婚证。冬天，我们举办了婚礼。一切都顺顺利利，妥妥当当。到现在，我仍然没有明显地感觉到婚前婚后的变化。这确实是我期望的。这一年，我和小珂相互关心，相互谦让。这样的生活让我很放松。结婚后，我们买了一套一百平的房子。虽然因为首付借了不少钱，而且今年的房价还有下降趋势。但是总体来说，这件事还是让我对未来充满了期待，十分开心。</p>

<p>  九月份，我和小珂去欧洲旅行了。古人说：“读万卷书，行万里路。”在遥远的异国他乡，我们走过罗马斗兽场旁的幽幽小巷；仰观富丽堂皇的圣母百花大教堂；沉浸于柔美的莱茵河与天边灿烂的晚霞。我深切地领会到“过秦、汉之故都，恣观终南、嵩、华之高，北顾黄河之奔流，慨然想见古之豪杰”的那种情怀。旅行确实激发了我内心的浩然之气。</p>

<p>  这一年，我在公司有一半多的时间投入在节点代码重构上。以前的代码充满了不同逻辑模块间的耦合关系，稍作改动都会引起一些潜在的问题。因此工程师十分抗拒修改代码。年初，我在“户外防潮型表面温度”项目中完成了 MSP430 平台上的重构工作，把这些耦合关系都基本消除。年中，我开始了带显示屏的室内环境监测终端产品线的开发。在这个项目中我基本解决了 STM32 + FreeRTOS 的开发问题。比较有意义的是 Bootloader 和低功耗问题的解决。后半年，我在部门中逐渐引入 Git Flow、持续集成、自动化单元测试等技术。年底，依托这些基础设施的提升，我参照敏捷开发和 CMMI，制定了部门内的研发流程。这一流程在部门范围内弥补了研发部流程执行不顺利的问题。</p>

<p>  我家的盆栽植物已经有大大小小21盆了。除过一盆金钱木，其他的盆栽都长势喜人。这盆金钱木也是命途多舛。我本来一直都控制着浇水，它也一直都健健康康的，还分出了三四个旁枝。谁知一次降温突然来临，叶子被冻黄了几片。刚开始我以为是冬天干燥，缺水造成的，所以多浇了几次。结果把它浇烂根了。好在我及时把根挖出来，凉了两天，再重新植回盆里，才把它挽救回来。不过现在的叶子都快掉秃了。希望过了新年它会有新气象。</p>

<p>  2019年也有一些遗憾。</p>

<p>  10月份，我去三星面试嵌入式软件工程师一职。技术面试毫无悬念地通过了，但是人力资源面试没过。回顾整个过程，我觉得最有可能出问题的地方是薪水要求太高了。今年有机会的话还想再试一次。为什么我如此想去三星呢？说实在的，步入三十岁，我慢慢开始担心中年危机的到来。这使我在换工作时更倾向于稳定的环境。</p>

<p>  原本计划要在2019年多看些书，结果达成度并不令我满意。我看了《思考，快与慢》和《Harry Potter and the Philosopher’s Stone》。一年两本的阅读量明显偏少。并不是我没有足够的时间阅读，而是在一些无意义的休闲上浪费了太多时间。今年我给自己定了看10本书的目标。这是一个量化的目标，并且切实可行。通过读书，一方面我可以拓宽知识面，另一方面可以锻炼自控能力。</p>

<p>  2020年也会像2019年一样快快地过去。也许2020年不会像2019年一样精彩，但是2020年一定会比2019年有更多收获。</p>

<p align="right">——2020年1月2日 晚</p>]]></content><author><name></name></author><summary type="html"><![CDATA[  昨天晚上，我和小珂出去吃饭。等餐的时候，和小珂闲在聊中谈到一年的变化。事后细想，感慨颇深。]]></summary></entry><entry><title type="html">使用 IAR Embedded Workbench IDE 做单元测试</title><link href="/2019/12/20/iar-unit-test" rel="alternate" type="text/html" title="使用 IAR Embedded Workbench IDE 做单元测试" /><published>2019-12-20T20:00:00+08:00</published><updated>2019-12-20T20:00:00+08:00</updated><id>/2019/12/20/iar-unit-test</id><content type="html" xml:base="/2019/12/20/iar-unit-test"><![CDATA[<h1 id="一欢迎">一、欢迎</h1>
<p>　　很高兴你能看到这篇文章，我将在这篇文章中介绍如何使用 IAR 做单元测试。</p>

<p>　　大部分嵌入式开发者一般都按照“编码——编译——运行——调试”的循环完成开发工作，这很可能只会用到 IAR Embedded Workbench IDE（以下简称“IAR”）极少一部分（同时也是最常用的）功能。实际上，IAR 为开发者提供了很多丰富的功能，使我们能做更多事情。</p>

<p>　　IAR 集成了“IAR C-SPY Debugger”，IAR C-SPY Debugger 里面又提供了“C-SPY Simulator”功能。它通过软件完整地模拟了目标处理器，使目标处理器的代码可以脱离硬件环境运行。这样就可以随时做单元测试而不必等待硬件环境就绪。对单元测试而言，这是一个极大的便利。顺便提一下，我使用的 IAR 版本是 IAR Embedded Workbench for ARM 8.32.3.20228。</p>

<h1 id="二创建工程">二、创建工程</h1>
<p>　　创建一个名为“test”的 C 语言模板工程，然后打开工程选项菜单，在”General Option”选项中的“Library Configuration”选项卡中，按下图所示配置。</p>

<p><img src="/assets/iar-ut/semihost.png" alt="debugger" /></p>

<p>　　Semihosting 是 ARM 处理器独有的特性。它能使 ARM 目标机通过调试器和主机通讯，或者使用主机的I/O设备。此功能可以单元测试程序使用 printf 等方法输出测试信息。非常方便。其他类型的处理器也会有相应的机制完成此任务。</p>

<p>　　接下来，在“Debugger”选项中将调试驱动选为“Simulator”。如下图所示：</p>

<p><img src="/assets/iar-ut/debugger.png" alt="debugger" /></p>

<p>　　打开 main.c 文件，修改其中的代码。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*main.c*/
#include &lt;stdio.h&gt;
int main()
{
    printf("Hello World\n");
    return 0;
}
</code></pre></div></div>
<p>　　这时候可以按“Ctrl+d”启动调试。进入调试界面后，选择“View”菜单的“Terminal I/O”，打开终端输入输出窗体。按“F5”继续运行代码，可以看到“Hello World”输出信息。这样，一个简单的工程就创建完成了。</p>

<h1 id="三添加单元测试框架">三、添加单元测试框架</h1>
<p>　　C 语言的单元测试框架很多，在这里不一一详述。我选择了Unity，项目地址见文末参考资料。下载“Unity-2.5.0.tar.gz”并解压。分别从“Unity-2.5.0/src”、“Unity-2.5.0/extras/fixture/src”和“Unity-2.5.0/extras/memory/src”中找到下列文件，并复制到 test 的工程目录中。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unity.c
unity.h
unity_fixture.c
unity_fixture.h
unity_fixture_internals.h
unity_internals.h
unity_memory.c
unity_memory.h
</code></pre></div></div>
<p>　　在 test 工程中添加以上的所有“.c”源文件，然后新建一个“foo.c”源文件作为待测文件。在 foo.c 中添加如下内容：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*foo.c*/
int add(int a, int b)
{
    return a + b;
}
</code></pre></div></div>
<p>　　再次修改 main.c，使用 Unity 框架，为 add 函数添加两个测试用例。</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*main.c*/
#include &lt;stdio.h&gt;
#include "unity_fixture.h"

extern int add(int a, int b);

static void run_all_test(void);

int main()
{
    const char *arg = "test";
    return UnityMain(1, &amp;arg, run_all_test);
}

void run_all_test(void)
{
    RUN_TEST_GROUP(add);
}

TEST_GROUP(add);

TEST_SETUP(add)
{
}

TEST_TEAR_DOWN(add)
{
}

TEST(add, case1)
{
    TEST_ASSERT_EQUAL(2, add(1, 1));
}

TEST(add, case2)
{
    TEST_ASSERT_EQUAL(-3, add(-1, -2));
}

TEST_GROUP_RUNNER(add)
{
    RUN_TEST_CASE(add, case1);
    RUN_TEST_CASE(add, case2);
}

</code></pre></div></div>
<p>　　运行程序后，可以看到终端输出信息。这两个测试用例已经全部通过了。</p>

<p>　　如何设计测试用例不在本文的讨论范围内，感兴趣的读者可以阅读 James W. Grenning 著的<a href="https://www.amazon.com/Driven-Development-Embedded-Pragmatic-Programmers-ebook/dp/B01D3TWF5M">《Test Driven Development for Embedded C》</a>。这本书从各个方面讲述了在嵌入式领域如何进行测试。</p>

<h1 id="四拓展">四、拓展</h1>
<p>　　在 test/settings 路径下，有这么几个文件：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test.Debug.cspy.bat
test.Debug.cspy.ps1
test.Release.cspy.bat
test.Release.cspy.ps1
</code></pre></div></div>
<p>　　Debug 和 release 表示配置，bat 表示 Windows 批处理程序，ps1 表示 Powershell 程序。在终端执行这些脚本可以调用 IAR C-SPY Debugger 运行程序，并且将结果输出至终端。这有助于自动化运行单元测试，我们以后还会详细讨论。</p>

<p>　　IAR 还提供了在终端中构建项目的工具，更多内容请参考<a href="https://www.iar.com/support/tech-notes/general/build-from-the-command-line/">这里</a>。</p>

<h1 id="五参考资料">五、参考资料</h1>
<ul>
  <li>https://github.com/ThrowTheSwitch/Unity</li>
  <li>http://www.keil.com/support/man/docs/armcc/armcc_pge1358787046598.htm</li>
</ul>]]></content><author><name></name></author><category term="IAR" /><category term="Unit Test" /><summary type="html"><![CDATA[一、欢迎 　　很高兴你能看到这篇文章，我将在这篇文章中介绍如何使用 IAR 做单元测试。]]></summary></entry><entry><title type="html">微光</title><link href="/2018/07/07/glimmer" rel="alternate" type="text/html" title="微光" /><published>2018-07-07T22:00:00+08:00</published><updated>2018-07-07T22:00:00+08:00</updated><id>/2018/07/07/glimmer</id><content type="html" xml:base="/2018/07/07/glimmer"><![CDATA[<p>　　今天已经是我到内蒙古赤峰市出差的第四天了。工作进行得并不顺利。下午设备故障，工程师维修了很久才解决问题。最后完成工作时，天已经黑了。</p>

<p>　　赤峰市位于内蒙古的东北方，夏天的夜晚来的要迟一些。晚上九点多，我们才启程返回。</p>

<p>　　我们乘坐的是一辆面包车，大概能坐十一二个人。车厢中间的过道上，凌乱地堆放着各种器械和背包。上车没过一会儿，同行的朋友们就在昏暗的车厢中睡着了。有的歪着脑袋靠在车窗上；有的低着头，随着车身的颠簸一起一伏；还有一个最舒服，他横躺在最后一排，把工作服叠起来，枕在头下。司机师傅在我们干活的时候在车里养足了精神，这会儿正聚精会神地开车。</p>

<p>　　我见副驾还空着，便小心翼翼地挪过去，坐下。本想和司机攀谈几句，免得他也生出睡意。可是寒暄两句后，却没有了话题。</p>

<p>　　我望向窗外。路边的树木唰唰得飞过，树影连在一起，看不清轮廓。尽管已经是九点多，不过天空还有微弱的亮光。不远处是连绵起伏的小山丘。山丘上的葱郁树木在昏暗中显得朦朦胧胧，分不清枝叶。衬在天边的亮光下，似娉婷的少女的背影。枝叶仿佛是她秀美的长辫，垂在腰间。</p>

<p>　　我喜欢这样的夜。内心在宁静的环境中慢慢安定下来，思绪在头脑中漫游，心中的牵挂一点点变得清晰。</p>

<p>　　转过一个弯，地势突然变得平坦了。山丘背后竟然钻出一丝微光。此时天已经完全黑了，窗外除了这一丝微光，什么也看不到。那微光时隐时现，穿过车窗显出淡淡的黄晕。</p>

<p>　　黑夜本没什么可怕，不过这微光的出现竟让我生出一些不安。我猜不出它是什么，也不知道它有多远。这微光竟变成我心里的一份期望，想要接近它，一探究竟。</p>

<p>　　车又转过一个弯，正对着那点微光前行。道路笔直，四周无物。车渐渐加速，我的心也加速跳起来。只要路的方向不变，我一定可以接近它。</p>

<p>　　恍惚中，我好像睡了过去。</p>

<p>　　梦中也有微光，它在我眼前渐渐放大，最后充满了整个视线，无比耀眼。之后那娉婷的少女背影出现在光源中心。</p>

<p>　　她摆动长发，慢慢地转过头来。</p>

<p align="right">——2018年7月7日 夜</p>]]></content><author><name></name></author><summary type="html"><![CDATA[　　今天已经是我到内蒙古赤峰市出差的第四天了。工作进行得并不顺利。下午设备故障，工程师维修了很久才解决问题。最后完成工作时，天已经黑了。]]></summary></entry><entry><title type="html">说看就看的日出</title><link href="/2018/02/21/sunrise-on-emei" rel="alternate" type="text/html" title="说看就看的日出" /><published>2018-02-21T01:12:10+08:00</published><updated>2018-02-21T01:12:10+08:00</updated><id>/2018/02/21/sunrise-on-emei</id><content type="html" xml:base="/2018/02/21/sunrise-on-emei"><![CDATA[<p>　　当我爬起床时，还不到凌晨三点。匆匆忙忙地穿好衣服后，我就出发了。</p>

<p>　　前一天，我已经从峨眉山的万年车站爬到了雷洞坪。天黑之前便找了个落脚的地方，住了下来。今天我的目标便是在登顶看日出。说来真是好笑：大过年的，从我产生去成都的念头到买到车票，只用了半个小时。接着，从产生去峨眉山看日出的念头到坐上车，也只用了半个小时。当真是说走就走的旅行，说看就看的日出。</p>

<p>　　初春时节，半山腰上的夜晚用春寒料峭形容再贴切不过了。即便穿上了厚厚的羽绒服和冲锋衣，也能感觉到细细的风就像一双魔手，划过脸颊，然后生生地，一点一点地将皮肤上的热量拽走。我打了个冷战，往山顶望了望，迈起了步子。</p>

<p>　　峨眉山并不像华山那样陡峭，但是战线却拉得很长。从半山腰的万年寺到金顶有差不多三四十公里的路程。道路蜿蜒曲折，千回百转。抬头看，远处一闪一闪的亮光，稀疏得装扮在半空中。再仔细看，能分辨出缓缓移动的是登山者发出的灯光。而那些静止不动的就不知道是休憩的人还是星光了。</p>

<p>　　从雷洞坪到金顶有大概两小时的路程。虽然不远，但是却非常难走。一方面是因为夜晚行进，另一方面是因为前一天爬了大部分的路程，休息一晚后虽然恢复了精力，但是整个小腿肌肉酸疼，十分难受。</p>

<p>　　周围很安静，西风“嘶嘶”地细声吹过，卷得四周的草木“哗哗”地低语。四周黑洞洞的，手电筒照过的地方偶然会惊扰到一些小动物。不过他们在我发现之前就“哗啦”一声逃之夭夭。有的甚至反而把我吓一大跳。</p>

<p>　　渐渐地，有人从我身边经过。有的还惊奇于我独自一人，停下来攀谈两句，相互叮嘱谨慎小心，然后继续前行。我有时候也从别人身边经过。一路上，能遇到形形色色的各种人。年轻的情侣们大多是男孩负重，同时还一路护着女孩；年长一些的大叔大妈们大多低头不语，看起来身手矫健，行进速度一点也不输年轻人；还有一家三口手牵手的，孩子看起来还睡眼惺忪，被爸妈一步一拽地往前走。有三五成群，欢声笑语的；有两人结伴，细声细语的；唯独不见有像我一样，茕茕孑立，形影相吊的。</p>

<p>　　金顶是峨眉山的顶峰，上面有一片平地。当我到达金顶时，天还没有任何一丝要亮的痕迹。不过这里已经聚集了不少等待观看日出的人。我又往回走了一些，坐在了一个石头上，远离了大部分人群。不知是天还没亮，还是大家都期盼着日出，诺大一片地方，如此多人，竟然不觉得喧嚣。</p>

<p>　　没过多久，天边就泛起了一丝鱼白，天空顿时被分作上下两半。渐渐地，细细的鱼白往上扩散、延伸。橙色的云霞也慢慢地从天地分界线中爬出来。从刚开始的模糊一片，慢慢地越来越清晰。到最后现出了云彩的轮廓。</p>

<p>　　一不留神，天边已经亮堂了。远方天地相接的地方形成了明显的反差。上面的天空是一片浅蓝，下面则是昏暗一片。</p>

<p>　　在一个毫不起眼的瞬间，太阳悄无声息地在云层中间探头探脑。人群中顿时引发一阵骚动，人们都在叫嚷着：“日出了，日出了！”随后，所有人仿佛是商量好的一般，又迅速安静了下来。</p>

<p>　　太阳一点一点升起来，从一丝丝身影到红彤彤的圆球。天际越发明亮，太阳越发清晰。</p>

<p>　　我以为我会很平静地欣赏日出，然而我分明感觉到我心里的弦越绷越紧。</p>

<p>　　太阳不断升高，云层似乎再也无法束缚住它。从红彤彤的圆球中渐渐迸发出明亮的黄色光亮。太阳正不断地展示出它惊人的生命力。远远望去，太阳周边的天空也被它带着抖动了起来。很快，太阳便彻底从云层中脱身，蒸腾而上。阳光一下子洒在了山顶所有人的脸上，人群中充满了欢呼声。不远处的情侣激动得热情拥吻。</p>

<p>　　这一刻，我觉得生命里一切付出都是值得的。我仿佛换了一个人一样，发自内心的开心。我好像突然重新认识了世界，对事物有了更深的理解。不知这是不是孟子所说的“浩然之气”，但是我确实感觉到内心的宽厚宏博，充乎天地之间。</p>

<p>　　美好的东西真的能够让人深陷其中，流连忘返。下山的路上，我一直在问自己：上山是为了什么，下山又是为了什么？</p>

<p align="right">——2018年2月21日 凌晨</p>]]></content><author><name></name></author><summary type="html"><![CDATA[　　当我爬起床时，还不到凌晨三点。匆匆忙忙地穿好衣服后，我就出发了。]]></summary></entry><entry><title type="html">Linux进程间通信概览</title><link href="/2018/01/15/helicopter-view-of-interprocess-communication" rel="alternate" type="text/html" title="Linux进程间通信概览" /><published>2018-01-15T20:45:00+08:00</published><updated>2018-01-15T20:45:00+08:00</updated><id>/2018/01/15/helicopter-view-of-interprocess-communication</id><content type="html" xml:base="/2018/01/15/helicopter-view-of-interprocess-communication"><![CDATA[<h1 id="一概要">一、概要</h1>
<p>　　最近一段时间，工作中经常会处理进程间通信相关的事情。于是将一些经验汇总一下。</p>

<p>　　总结起来，Linux下进程间通信主要有以下几种方法：</p>
<ol>
  <li>信号（Signal）</li>
  <li>管道（Pipe）和命名管道（Named pipe）</li>
  <li>消息队列（Message queue）</li>
  <li>共享内存（Shared memory）</li>
  <li>信号量（Semaphore）</li>
  <li>套接字（Socket）</li>
</ol>

<p>　　在众多的进程间通信的方法里面，每一种方法都有优缺点，如何根据使用情景选择合适的通信方法就非常重要了。</p>

<h1 id="二信号">二、信号</h1>
<p>　　信号是非常基础的进程间通信方法，它从软件层面上对中断机制进行了模仿。所以信号也被称作“软中断信号”。信号用来通知进程发生了异步事件。进程之间可以通过系统调用发送软中断信号。操作系统内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。Linux支持不可靠信号和可靠信号。</p>

<p>　　Linux系统共定义了64种信号，分为两大类：实时信号与标准信号，前32种信号（信号值小于SIGRTMIN）为标准信号（也称之为不可靠信号和非实时信号），后32种（信号值位于SIGRTMIN和SIGRTMAX之间）为实时信号（也称之为可靠信号）。信号很重要的一个特点就是当进程接收到信号后，能够中断当前执行的代码，转而执行信号处理函数。实时信号和标准信号有如下区别：</p>
<ul>
  <li>实时信号没有明确的含义，而是由使用者自己来决定如何使用。而标准信号则一般有确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的CTRL+C时，会产生SIGINT信号，进程对该信号的默认反应就是进程终止。</li>
  <li>一个进程可以接受多个同样的实时信号，这些实时信号会被缓存在一个队列中，然后按次序被处理。而标准信号则不能。在标准信号没有得到处理的时候，多个标准信号会被合为一个。这也造成了标准信号可能丢失的情况。</li>
  <li>实时信号使用sigqueue发送的时候，可以携带附加的数据(int或者pointer)。标准信号不能。</li>
  <li>实时信号具有优先级的概念，数值越低的实时信号其优先级越高。在处理的时候，也是数值低的实时信号优先得到处理。</li>
  <li>实时信号的默认行为都一样，都是结束当前的进程，这个和标准信号是不一样的。</li>
  <li>进程每次处理标准信号后，就将对信号的响应设置为默认动作。在某些情况下，将导致对信号的错误处理。因此，用户如果不希望这样的操作，那么就要在信号处理函数结尾再一次调用signal()，重新安装该信号<sup>[注1]</sup>。</li>
</ul>

<p>　　信号的相关API：</p>

<ul>
  <li>signal()：安装信号</li>
  <li>sigaction()：安装信号</li>
  <li>kill()：向进程或进程组发送信号</li>
  <li>sigqueue()：发送信号</li>
  <li>alarm()：调用进程指定时间后发出SIGALARM信号</li>
  <li>setitimer()：设置定时器，计时达到后给进程发送SIGALRM信号</li>
  <li>abort()：向进程发送SIGABORT信号，默认进程会异常退出</li>
  <li>raise()：向进程自身发送信号</li>
  <li>sigemptyset()：信号集全部清0</li>
  <li>sigfillset()：信号集全部置1</li>
  <li>sigaddset()：向信号集中加入signum信号</li>
  <li>sigdelset()：向信号集中删除signum信号</li>
  <li>sigismember()：判定信号signum是否存在信号集中</li>
  <li>sigprocmask()：把信号集中的信号添加到进程信号集</li>
  <li>sigpending()：获取已发送到进程，却被阻塞的所有信号</li>
  <li>sigsuspend()：替换进程的原有掩码，并暂停进程执行，直到收到信号再恢复原有掩码并继续执行进程</li>
</ul>

<p>　　值得注意的是：</p>
<ul>
  <li>由于信号会中断主进程的运行，所以在信号处理函数中多任务的并发控制也会经常使用。当主进程获取某个资源并加锁后，如果在它解锁前接收到了一个信号并进入了信号处理函数，并且在这个信号处理函数中，同样需要获取此资源并加锁。但是主进程还没有解锁，这就会导致死锁。所以，在信号处理函数中进行并发控制需要格外小心。</li>
  <li>当进程正阻塞在系统调用（或者库函数）中时，如果一个信号处理函数被调用。此时会出现两种情况：1.信号处理函数返回后，自动重新进入系统调用（库函数调用）。2.系统调用（库函数）失败并且返回EINTR。具体情况请参考Linux man pages。</li>
</ul>

<h1 id="三管道">三、管道</h1>
<p>　　管道是所有进程间通信手段中最简单的一种。对于进程来说，管道和文件类似。命名管道和管道的区别仅在于创建和打开的方式不同。</p>

<p>　　在Linux man pages中，命名管道被称作FIFO。管道和命名管道都提供了单向的进程间通信的通道。管道有一个读取端和一个写入端。数据从写入端写入，从读取端读取。由于管道的特点和创建管道的方法限制，导致管道只能用于具有亲缘关系的进程之间。命名管道（FIFO）和管道非常类似。只不过它在文件系统中有唯一的文件与之对应。读取端使用O_RDONLY标志打开，而写入端则是用O_WRONLY打开。管道和命名管道只能发送无格式的字节流，并且其容纳数据的缓冲区大小是受限制的。</p>

<p>　　管道的相关API：</p>
<ul>
  <li>pipe()：创建并打开匿名管道</li>
  <li>mkfifo()：创建命名管道</li>
  <li>unlink()：销毁命名管道</li>
</ul>

<p>　　管道的读写操作和文件操作基本一致。不过需要注意的是，以阻塞方式打开和读写命名管道时，阻塞方式和普通文件有所区别。具体情况请参考Linux man pages。</p>

<h1 id="四消息队列">四、消息队列</h1>
<p>　　消息队列就是一个消息的链表。可以把消息看作一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向中按照一定的规则添加新消息；对消息队列有读权限的进程则可以从消息队列中读走消息。消息队列解决了信号只能通知事件，而不能发送信息的问题。同时又克服了管道只能承载无格式字节流以及缓冲区大小受限等缺点。结构化的消息通信机制使通信双方在约定好数据结构之后，无须对消息再次解析。</p>

<p>　　Linux既支持POSIX消息队列，也支持System V 消息队列，相关API如下所示：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">POSIX 函数</th>
      <th style="text-align: left">System V 函数</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">创建消息队列</td>
      <td style="text-align: left">mq_open()</td>
      <td style="text-align: left">msgget()</td>
    </tr>
    <tr>
      <td style="text-align: left">发送消息</td>
      <td style="text-align: left">mq_send()<br />mq_timedsend()</td>
      <td style="text-align: left">msgsnd()</td>
    </tr>
    <tr>
      <td style="text-align: left">接收消息</td>
      <td style="text-align: left">mq_receive()<br />mq_timedreceive()</td>
      <td style="text-align: left">msgrcv()</td>
    </tr>
    <tr>
      <td style="text-align: left">操作消息队列</td>
      <td style="text-align: left">mq_getattr()<br />mq_setattr()</td>
      <td style="text-align: left">msgctl()</td>
    </tr>
    <tr>
      <td style="text-align: left">消息队列通知</td>
      <td style="text-align: left">mq_notify()</td>
      <td style="text-align: left">-</td>
    </tr>
  </tbody>
</table>

<p><br />
　　消息队列具有内核延续性。所谓内核延续性是指：某个资源创建后会随着内核的运行而一直存在，直到这个资源被有意的回收。相似的概念还有进程延续性和文件系统延续性。</p>

<p>　　Linux中POSIX消息队列的描述符直接使用了文件描述符，这意味着可以使用select、poll和epoll来操作消息队列。不过这些并不包含在POSIX标准中，所以这一特性不能保证可移植性。</p>

<h1 id="五共享内存">五、共享内存</h1>
<p>　　采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。不过共享内存往往要配合其他的通信方法使用，来达到进程间的同步及互斥。</p>

<p>　　Linux同样也支持POSIX共享内存和System V 共享内存，相关API如下所示：</p>

<ul>
  <li>shm_open()：（POSIX）创建并打开共享内存</li>
  <li>ftruncate()：（POSIX）设置共享内存大小</li>
  <li>mmap()：（POSIX）映射共享内存至虚拟进程空间</li>
  <li>munmap()：（POSIX）取消共享内存映射</li>
  <li>shm_unlink()：（POSIX）删除共享内存</li>
  <li>close()：（POSIX）关闭共享内存描述符</li>
  <li>fstat()：（POSIX）获取共享内存状态</li>
  <li>fchown()：（POSIX）更改共享内存所属</li>
  <li>fchmod()：（POSIX）更改共享内存访问权限</li>
  <li>shmget()：（System V）创建并打开共享内存</li>
  <li>shmat()：（System V）映射共享内存至虚拟进程空间</li>
  <li>shmctl()：（System V）设置共享内存空间</li>
  <li>shmdt()：（System V）取消共享内存映射</li>
</ul>

<p>　　共享内存具有内核延续性。</p>

<h1 id="六信号量">六、信号量</h1>
<p>　　信号量使用一个正整数来表示的，通常用在进程间同步上。对信号量有两种操作：1.给信号量加1；2.给信号量减1。当信号量为0时，减1操作会阻塞，直到信号量不为0。</p>

<p>　　在POSIX标准中，信号量分两种，匿名信号量和命名信号量。类似命名管道，命名信号量会以文件系统中的一个文件作为名字。所以命名信号量一般用于进程间同步。匿名信号量顾名思义没有名字，所以一般用于线程间同步。当需要用于进程间同步时需要将匿名信号量放置在共享内存中。</p>

<p>　　需要注意的是：和匿名管道不同，匿名信号量不能直接用于父子进程之间。</p>

<p>　　Linux支持POSIX信号量和System V 信号量，相关API如下所示：</p>

<ul>
  <li>sem_open()：（POSIX）创建并打开信号量</li>
  <li>sem_init()：（POSIX）初始化信号量</li>
  <li>sem_getvalue()：（POSIX）获取信号量的值</li>
  <li>sem_post()：（POSIX）post操作</li>
  <li>sem_wait()：（POSIX）wait操作</li>
  <li>sem_close()：（POSIX）关闭信号量</li>
  <li>sem_destroy()：（POSIX）销毁信号量</li>
  <li>sem_unlink()：（POSIX）销毁信号量</li>
  <li>semget()：（System V）创建并打开信号量</li>
  <li>semctl()：（System V）控制信号量</li>
  <li>semop()：（System V）操作信号量</li>
</ul>

<p>　　System V 信号量非常难用，在此就不做介绍了。</p>

<p>　　命名信号量具有内核延续性，匿名信号量如果没有放在共享内存中的话具有进程延续性，如果放在共享内存中，我猜测应该会跟随共享内存的生命周期。</p>

<h1 id="七套接字">七、套接字</h1>
<p>　　是的，你没有看错，套接字不仅用于网络通信，还可用于进程间通信。非但如此，套接字在设计之初便充分考虑到了进程间通信。套接字最早出现在《RFC 147:The Definition of a Socket》标准中，用于ARPANET（The Advanced Research Projects Agency Network）中。之后便发展出了用于TCP/IP协议的网络套接字（Network sockets）和用于进程间通信的Unix域套接字（Unix Domain sockets）。后来伯克利套接字（Berkeley sockets，也称作BSD sockets）基于前两者的基础上，随着4.2 BSD Unix操作系统发展起来。然而后来伯克利套接字慢慢被POSIX套接字所取代。</p>

<p>　　Linux实现了POSIX套接字。创建时选择相应的域和协议，便可以使用套接字进行进程间通信。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span></code></pre></figure>

<p>　　分别为domain和type传入AF_UNIX和SOCK_SEQPACKET便可创建一个套接字来支持Unix域套接字。它保证了通信的可靠性和有序性。</p>

<h1 id="八其他">八、其他</h1>
<p>　　我们注意到：有POSIX和System V两套标准都支持信号量、消息队列和共享内存。为什么会这样呢？他们两个有什么区别呢？应该如何选择呢？</p>

<p>　　System V实际上指的是Unix System V。这里V是罗马数字五，读作“System Five”。1983年，UNIX System V是第一个发布的商业版的Unix操作系统。随着Unix操作系统的成功，Unix中的各种特性成为操作系统界的事实标准。后来直接使用“System V”来指代此标准。而POSIX标准虽然起源于1988年，但是直到2001年才被IEEE标准委员会所接纳。Linux的初版于1991年发布，所以最早支持了System V标准。不过由于POSIX在很多地方都优秀于System V，所以POSIX标准也逐渐被大部分人接受。</p>

<ul>
  <li>按照Linux man pages的说法，System V是比较古老的接口，有很多设计不合理的地方。POSIX吸取了很多经验，提供了更加友好的接口设计。但是由于POSIX比较年轻，有些平台并没有完整的实现，尤其是比较古老的系统。</li>
  <li>按照《UNIX, Third Edition: The Textbook》上的说法，POSIX的进程间通信是线程安全的，而System V的不是。我还未对此作验证。</li>
  <li>由于POSIX标准的设计目标就是可移植性，所以POSIX的进程间通信方式更具可移植性。</li>
  <li>POSIX提供了更多的功能，比如支持select，poll等方法。</li>
</ul>

<p>注1：Linux支持不可靠信号，但是对不可靠信号机制做了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数（信号安装函数是在可靠机制上的实现）。因此，Linux下的不可靠信号问题主要指的是信号可能丢失。</p>

<p>参考：</p>
<ul>
  <li>Linux Man Pages</li>
  <li>Wikipedia</li>
</ul>]]></content><author><name></name></author><summary type="html"><![CDATA[一、概要 　　最近一段时间，工作中经常会处理进程间通信相关的事情。于是将一些经验汇总一下。]]></summary></entry><entry><title type="html">三年牡丹</title><link href="/2015/02/19/three-years-of-planting-peony" rel="alternate" type="text/html" title="三年牡丹" /><published>2015-02-19T02:12:10+08:00</published><updated>2015-02-19T02:12:10+08:00</updated><id>/2015/02/19/three-years-of-planting-peony</id><content type="html" xml:base="/2015/02/19/three-years-of-planting-peony"><![CDATA[<p>　　小时候是在地质八队长大的。说那个院子依山傍水一点也不为过。后墙依着秦岭的小土丘，西边靠着太平河，仅有半条街那么远。</p>

<p>　　前前后后搬过几次家，后来稳定在了一排小窑洞里。一大一小的套间，外面有个厨房。厨房门口有个方形的小花坛。</p>

<p>　　有一年夏天，朋友送给我一株牡丹。我随手插在了花坛里，浇了浇水。</p>

<p>　　牡丹出乎意料地活了。记忆中，它抽出了不少的新叶。每天放学回家，还没放下书包就蹲在花坛边看它。忍不住用手摸嫩嫩的叶子，又怕太用力伤了它。</p>

<p>　　来年春天，那是个周末。早上挨了母亲一顿打，她中场休息时，我被罚站在花坛前。猛然看到那株牡丹竟然长出了一个花蕾。</p>

<p>　　花蕾小如黄豆一样夹在叶柄。顶端还没有裂开，看不到是什么颜色的花。但它分明就是一个花蕾！</p>

<p>　　一时间我就忘了还在挨骂中，蹲下来贴近了仔细看。我没有用手碰，生怕一下就碰掉在地上。愣了半天才想起来浇水。那时候什么也不懂，“你多喝点水”就是所有的关心手段了。</p>

<p>　　在开花的憧憬中过了几天。不知道为什么，那朵花蕾最终还是没有开出花朵。在我发现它掉落在地上的那天中午，我伤心地蹲在地上很久，内心的苦闷让我有把它拔出来的冲动。</p>

<p>　　最终，我还是又给它浇了浇水。我知道，即使这样，我还是打心眼儿里喜欢它。</p>

<p>　　春去秋来，它又掉了叶子。似乎那个凋落的花骨朵让我觉得它很脆弱，我对它的照顾更加多了。埋蛋壳似乎都觉得还不够，我甚至给它打过一个鸡蛋，埋在旁边的土里。当然，被发现免不了又是一顿打。</p>

<p>　　不过我仍然开心着。</p>

<p>　　那年，下了一场很大的雨。有多大？后来据说太平河的河水已经漫到了桥面上。我逃了自习课，跑回家，在旁边的葡萄树上绑了一把雨伞，希望为它遮风挡雨。</p>

<p>　　第二天雨停了，伞被吹不见了。</p>

<p>　　它还在，只不过叶子都没了。我很担心，非常担心。</p>

<p>　　好在第二年春天，它又抽出了嫩叶。</p>

<p>　　它比我想象得坚强很多。</p>

<p>　　已经不记得它开花时我有多开心，反正当时不知道从哪里偷了一个破旧的竹扫把，用这扫把给它做了个小篱笆。</p>

<p>　　我蹲在牡丹前面，看不够。真是艳丽无比。</p>

<p>　　母亲说，拿这个牡丹写一篇作文吧。我竟然开心地答应了。</p>

<p>　　不可思议……</p>

<p>　　我只见过它开过这一次花。那年冬，我家搬到了西安，我也转学过来，上六年级。忙着插班考试，走得匆忙，没有带上它。</p>

<p>　　若干年后，我回去过那个院子。能拆的都被拆了。</p>

<p>　　人是物非。</p>

<p>　　我觉得它始终都是属于我的。直到我看了那句“念桥边红药，年年知为谁生？”</p>

<p>　　姜夔当年21岁，写下这首《扬州慢》。</p>

<p>　　那一年，我也差不多那么大。我倒想知道，当年的姜夔如何加上曲子，唱出内心的凄美怅惘。</p>

<p>　　走时，环顾空荡荡的院子，好一个“清角吹寒，都在空城”！</p>

<p align="right">——2015年2月19日 凌晨</p>]]></content><author><name></name></author><summary type="html"><![CDATA[　　小时候是在地质八队长大的。说那个院子依山傍水一点也不为过。后墙依着秦岭的小土丘，西边靠着太平河，仅有半条街那么远。]]></summary></entry><entry><title type="html">那些年，我们遵守的承诺</title><link href="/2012/05/06/the-promises-we-kept" rel="alternate" type="text/html" title="那些年，我们遵守的承诺" /><published>2012-05-06T08:00:00+08:00</published><updated>2012-05-06T08:00:00+08:00</updated><id>/2012/05/06/the-promises-we-kept</id><content type="html" xml:base="/2012/05/06/the-promises-we-kept"><![CDATA[<p>  吃过晚饭，趁着天色还明亮，我提着水桶在楼下洗车。边上有一堆沙子，邻居家的小女孩拿着小铲子独自玩得不亦乐乎。</p>

<p>  没过一会，来了一个小男孩。他总是和她在一起玩，我经常见。</p>

<p>  小男孩脸上洋溢着笑，说：“咱俩一起玩吧！”</p>

<p>  女孩看了他一下，脸上也不高兴：“不行，昨天你都不听我话。”</p>

<p>  男孩蹲下来，手里抓着沙子说：“我今天听你话！”</p>

<p>  “不信！再说我马上回家吃饭了”</p>

<p>  “你吃饭的时候，我在这等你。”</p>

<p>  “拉钩！”</p>

<p>  “好！”</p>

<p>  两个小家伙一本正经的开始“拉钩上吊”。</p>

<p>  女孩的妈妈从楼上窗户探出头，叫了女孩的名字。女孩起来拍拍手，跑上楼去。男孩接过铲子继续着女孩未完成的“事业”。</p>

<p>  之后，陆续有两三个伙伴来叫男孩去别处玩。男孩只是抬头说“我在等西西”。</p>

<p>  大约过了半个小时，我刚擦完车，正准备离开。女孩才跑下楼来，跳着笑着加入男孩。</p>

<p>  我提着桶上楼时，回头看了一眼。两个小家伙认真的过着家家，俨然一副要白头偕老的架势。</p>

<p>  人与人之间的承诺，莫不过如此。长大了，懂得多了，却忽视了本来很重要的东西。</p>

<p>  成长的同时，也回头看看！那些年，我们遵守的承诺！</p>

<p align="right">——2012年05月06日</p>]]></content><author><name></name></author><category term="思考" /><category term="生活" /><summary type="html"><![CDATA[  吃过晚饭，趁着天色还明亮，我提着水桶在楼下洗车。边上有一堆沙子，邻居家的小女孩拿着小铲子独自玩得不亦乐乎。]]></summary></entry></feed>